snippet type "type <name> struct {...}"
type ${1:name} struct {
	$0
}
endsnippet

snippet makes "<name> := make([]<slicetype>, 0)"
${2:varname} := make([]${1:type}, 0)
$0
endsnippet

snippet makem "<name> := make(map[<key>]<value>, 0)"
${3:varname} := make(map[${1:key}]${2:value}, 0)
$0
endsnippet

snippet fn "func name() {} free function"
func ${1:Name}($2) $3 {
	$0
	return $4
}
endsnippet

snippet fns "func (s *S) name() {} struct function"
func (${1:this} *${2:Struct}) ${3:Name}($4) $5 {
	$0
}
endsnippet

snippet fnsr "func (s *S) name() {} struct function with return"
func (${1:this} *${2:Struct}) ${3:Name}($4) $5 {
	$0
	return $6
}
endsnippet

snippet test "func Test_(t *testing.T) goblin test"
func Test_${1}(t *testing.T) {
	g := goblin.Goblin(t)
	$0
}
endsnippet

snippet describe "g.Describe(...) goblin test block"
g.Describe("$1", func() {
	g.It("$2", func() {
		$0
	})
})
endsnippet

snippet it "g.It(...) goblin test block"
g.It("$1", func() {
	$0
})
endsnippet

snippet date "2006-01-02T15:04:05Z07:00 (RFC3339)"
"2006-01-02T15:04:05Z07:00"
endsnippet

snippet gracefulshutdown "Graceful shutdown with deadline"
// graceful shutdown with deadline
c := make(chan os.Signal, 1)
signal.Notify(c, os.Interrupt)
<-c

ctx, cancel := context.WithTimeout(context.Background(), 15*time.Second)
defer cancel()
srv.Shutdown(ctx)
endsnippet

snippet httphandler "stdlib HTTP handler"
func $1(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, "$0")
}
endsnippet

snippet jsonencode "json encode map[string]interface{}"
	json.NewEncoder($1).Encode(map[string]interface{}{
		$0,
	})
endsnippet

snippet logoutput "set log output"
f, err := os.OpenFile("$0test.log", os.O_APPEND|os.O_CREATE|os.O_RDWR, 0666)
if err != nil {
	panic("Can't create log file")
}
defer f.Close()

log.SetOutput(f)
endsnippet
